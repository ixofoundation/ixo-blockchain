// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ixo/bonds/v1beta1/query.proto

package types

import (
	context "context"
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QueryBondsRequest is the request type for the Query/Bonds RPC method.
type QueryBondsRequest struct {
}

func (m *QueryBondsRequest) Reset()         { *m = QueryBondsRequest{} }
func (m *QueryBondsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryBondsRequest) ProtoMessage()    {}
func (*QueryBondsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{0}
}
func (m *QueryBondsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBondsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBondsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBondsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBondsRequest.Merge(m, src)
}
func (m *QueryBondsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryBondsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBondsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBondsRequest proto.InternalMessageInfo

// QueryBondsResponse is the response type for the Query/Bonds RPC method.
type QueryBondsResponse struct {
	Bonds []string `protobuf:"bytes,1,rep,name=bonds,proto3" json:"bonds,omitempty"`
}

func (m *QueryBondsResponse) Reset()         { *m = QueryBondsResponse{} }
func (m *QueryBondsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryBondsResponse) ProtoMessage()    {}
func (*QueryBondsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{1}
}
func (m *QueryBondsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBondsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBondsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBondsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBondsResponse.Merge(m, src)
}
func (m *QueryBondsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryBondsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBondsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBondsResponse proto.InternalMessageInfo

func (m *QueryBondsResponse) GetBonds() []string {
	if m != nil {
		return m.Bonds
	}
	return nil
}

// QueryBondsDetailedRequest is the request type for the Query/BondsDetailed RPC
// method.
type QueryBondsDetailedRequest struct {
}

func (m *QueryBondsDetailedRequest) Reset()         { *m = QueryBondsDetailedRequest{} }
func (m *QueryBondsDetailedRequest) String() string { return proto.CompactTextString(m) }
func (*QueryBondsDetailedRequest) ProtoMessage()    {}
func (*QueryBondsDetailedRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{2}
}
func (m *QueryBondsDetailedRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBondsDetailedRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBondsDetailedRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBondsDetailedRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBondsDetailedRequest.Merge(m, src)
}
func (m *QueryBondsDetailedRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryBondsDetailedRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBondsDetailedRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBondsDetailedRequest proto.InternalMessageInfo

// QueryBondsDetailedResponse is the response type for the Query/BondsDetailed
// RPC method.
type QueryBondsDetailedResponse struct {
	BondsDetailed []*BondDetails `protobuf:"bytes,1,rep,name=bonds_detailed,json=bondsDetailed,proto3" json:"bonds_detailed,omitempty"`
}

func (m *QueryBondsDetailedResponse) Reset()         { *m = QueryBondsDetailedResponse{} }
func (m *QueryBondsDetailedResponse) String() string { return proto.CompactTextString(m) }
func (*QueryBondsDetailedResponse) ProtoMessage()    {}
func (*QueryBondsDetailedResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{3}
}
func (m *QueryBondsDetailedResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBondsDetailedResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBondsDetailedResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBondsDetailedResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBondsDetailedResponse.Merge(m, src)
}
func (m *QueryBondsDetailedResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryBondsDetailedResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBondsDetailedResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBondsDetailedResponse proto.InternalMessageInfo

func (m *QueryBondsDetailedResponse) GetBondsDetailed() []*BondDetails {
	if m != nil {
		return m.BondsDetailed
	}
	return nil
}

// QueryBondRequest is the request type for the Query/Bond RPC method.
type QueryBondRequest struct {
	BondDid string `protobuf:"bytes,1,opt,name=bond_did,json=bondDid,proto3" json:"bond_did,omitempty"`
}

func (m *QueryBondRequest) Reset()         { *m = QueryBondRequest{} }
func (m *QueryBondRequest) String() string { return proto.CompactTextString(m) }
func (*QueryBondRequest) ProtoMessage()    {}
func (*QueryBondRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{4}
}
func (m *QueryBondRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBondRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBondRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBondRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBondRequest.Merge(m, src)
}
func (m *QueryBondRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryBondRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBondRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBondRequest proto.InternalMessageInfo

func (m *QueryBondRequest) GetBondDid() string {
	if m != nil {
		return m.BondDid
	}
	return ""
}

// QueryBondResponse is the response type for the Query/Bond RPC method.
type QueryBondResponse struct {
	Bond *Bond `protobuf:"bytes,1,opt,name=bond,proto3" json:"bond,omitempty"`
}

func (m *QueryBondResponse) Reset()         { *m = QueryBondResponse{} }
func (m *QueryBondResponse) String() string { return proto.CompactTextString(m) }
func (*QueryBondResponse) ProtoMessage()    {}
func (*QueryBondResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{5}
}
func (m *QueryBondResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBondResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBondResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBondResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBondResponse.Merge(m, src)
}
func (m *QueryBondResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryBondResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBondResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBondResponse proto.InternalMessageInfo

func (m *QueryBondResponse) GetBond() *Bond {
	if m != nil {
		return m.Bond
	}
	return nil
}

// QueryBatchRequest is the request type for the Query/Batch RPC method.
type QueryBatchRequest struct {
	BondDid string `protobuf:"bytes,1,opt,name=bond_did,json=bondDid,proto3" json:"bond_did,omitempty"`
}

func (m *QueryBatchRequest) Reset()         { *m = QueryBatchRequest{} }
func (m *QueryBatchRequest) String() string { return proto.CompactTextString(m) }
func (*QueryBatchRequest) ProtoMessage()    {}
func (*QueryBatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{6}
}
func (m *QueryBatchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBatchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBatchRequest.Merge(m, src)
}
func (m *QueryBatchRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryBatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBatchRequest proto.InternalMessageInfo

func (m *QueryBatchRequest) GetBondDid() string {
	if m != nil {
		return m.BondDid
	}
	return ""
}

// QueryBatchResponse is the response type for the Query/Batch RPC method.
type QueryBatchResponse struct {
	Batch *Batch `protobuf:"bytes,1,opt,name=batch,proto3" json:"batch,omitempty"`
}

func (m *QueryBatchResponse) Reset()         { *m = QueryBatchResponse{} }
func (m *QueryBatchResponse) String() string { return proto.CompactTextString(m) }
func (*QueryBatchResponse) ProtoMessage()    {}
func (*QueryBatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{7}
}
func (m *QueryBatchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBatchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBatchResponse.Merge(m, src)
}
func (m *QueryBatchResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryBatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBatchResponse proto.InternalMessageInfo

func (m *QueryBatchResponse) GetBatch() *Batch {
	if m != nil {
		return m.Batch
	}
	return nil
}

// QueryLastBatchRequest is the request type for the Query/LastBatch RPC method.
type QueryLastBatchRequest struct {
	BondDid string `protobuf:"bytes,1,opt,name=bond_did,json=bondDid,proto3" json:"bond_did,omitempty"`
}

func (m *QueryLastBatchRequest) Reset()         { *m = QueryLastBatchRequest{} }
func (m *QueryLastBatchRequest) String() string { return proto.CompactTextString(m) }
func (*QueryLastBatchRequest) ProtoMessage()    {}
func (*QueryLastBatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{8}
}
func (m *QueryLastBatchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryLastBatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryLastBatchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryLastBatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryLastBatchRequest.Merge(m, src)
}
func (m *QueryLastBatchRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryLastBatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryLastBatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryLastBatchRequest proto.InternalMessageInfo

func (m *QueryLastBatchRequest) GetBondDid() string {
	if m != nil {
		return m.BondDid
	}
	return ""
}

// QueryLastBatchResponse is the response type for the Query/LastBatch RPC
// method.
type QueryLastBatchResponse struct {
	LastBatch *Batch `protobuf:"bytes,1,opt,name=last_batch,json=lastBatch,proto3" json:"last_batch,omitempty"`
}

func (m *QueryLastBatchResponse) Reset()         { *m = QueryLastBatchResponse{} }
func (m *QueryLastBatchResponse) String() string { return proto.CompactTextString(m) }
func (*QueryLastBatchResponse) ProtoMessage()    {}
func (*QueryLastBatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{9}
}
func (m *QueryLastBatchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryLastBatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryLastBatchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryLastBatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryLastBatchResponse.Merge(m, src)
}
func (m *QueryLastBatchResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryLastBatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryLastBatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryLastBatchResponse proto.InternalMessageInfo

func (m *QueryLastBatchResponse) GetLastBatch() *Batch {
	if m != nil {
		return m.LastBatch
	}
	return nil
}

// QueryCurrentPriceRequest is the request type for the Query/CurrentPrice RPC
// method.
type QueryCurrentPriceRequest struct {
	BondDid string `protobuf:"bytes,1,opt,name=bond_did,json=bondDid,proto3" json:"bond_did,omitempty"`
}

func (m *QueryCurrentPriceRequest) Reset()         { *m = QueryCurrentPriceRequest{} }
func (m *QueryCurrentPriceRequest) String() string { return proto.CompactTextString(m) }
func (*QueryCurrentPriceRequest) ProtoMessage()    {}
func (*QueryCurrentPriceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{10}
}
func (m *QueryCurrentPriceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryCurrentPriceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryCurrentPriceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryCurrentPriceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryCurrentPriceRequest.Merge(m, src)
}
func (m *QueryCurrentPriceRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryCurrentPriceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryCurrentPriceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryCurrentPriceRequest proto.InternalMessageInfo

func (m *QueryCurrentPriceRequest) GetBondDid() string {
	if m != nil {
		return m.BondDid
	}
	return ""
}

// QueryCurrentPriceResponse is the response type for the Query/CurrentPrice RPC
// method.
type QueryCurrentPriceResponse struct {
	CurrentPrice github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,1,rep,name=current_price,json=currentPrice,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"current_price"`
}

func (m *QueryCurrentPriceResponse) Reset()         { *m = QueryCurrentPriceResponse{} }
func (m *QueryCurrentPriceResponse) String() string { return proto.CompactTextString(m) }
func (*QueryCurrentPriceResponse) ProtoMessage()    {}
func (*QueryCurrentPriceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{11}
}
func (m *QueryCurrentPriceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryCurrentPriceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryCurrentPriceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryCurrentPriceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryCurrentPriceResponse.Merge(m, src)
}
func (m *QueryCurrentPriceResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryCurrentPriceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryCurrentPriceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryCurrentPriceResponse proto.InternalMessageInfo

func (m *QueryCurrentPriceResponse) GetCurrentPrice() github_com_cosmos_cosmos_sdk_types.DecCoins {
	if m != nil {
		return m.CurrentPrice
	}
	return nil
}

// QueryCurrentReserveRequest is the request type for the Query/CurrentReserve
// RPC method.
type QueryCurrentReserveRequest struct {
	BondDid string `protobuf:"bytes,1,opt,name=bond_did,json=bondDid,proto3" json:"bond_did,omitempty"`
}

func (m *QueryCurrentReserveRequest) Reset()         { *m = QueryCurrentReserveRequest{} }
func (m *QueryCurrentReserveRequest) String() string { return proto.CompactTextString(m) }
func (*QueryCurrentReserveRequest) ProtoMessage()    {}
func (*QueryCurrentReserveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{12}
}
func (m *QueryCurrentReserveRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryCurrentReserveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryCurrentReserveRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryCurrentReserveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryCurrentReserveRequest.Merge(m, src)
}
func (m *QueryCurrentReserveRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryCurrentReserveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryCurrentReserveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryCurrentReserveRequest proto.InternalMessageInfo

func (m *QueryCurrentReserveRequest) GetBondDid() string {
	if m != nil {
		return m.BondDid
	}
	return ""
}

// QueryCurrentReserveResponse is the response type for the Query/CurrentReserve
// RPC method.
type QueryCurrentReserveResponse struct {
	CurrentReserve []types.Coin `protobuf:"bytes,1,rep,name=current_reserve,json=currentReserve,proto3" json:"current_reserve"`
}

func (m *QueryCurrentReserveResponse) Reset()         { *m = QueryCurrentReserveResponse{} }
func (m *QueryCurrentReserveResponse) String() string { return proto.CompactTextString(m) }
func (*QueryCurrentReserveResponse) ProtoMessage()    {}
func (*QueryCurrentReserveResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{13}
}
func (m *QueryCurrentReserveResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryCurrentReserveResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryCurrentReserveResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryCurrentReserveResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryCurrentReserveResponse.Merge(m, src)
}
func (m *QueryCurrentReserveResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryCurrentReserveResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryCurrentReserveResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryCurrentReserveResponse proto.InternalMessageInfo

func (m *QueryCurrentReserveResponse) GetCurrentReserve() []types.Coin {
	if m != nil {
		return m.CurrentReserve
	}
	return nil
}

// QueryAvailableReserveRequest is the request type for the
// Query/AvailableReserve RPC method.
type QueryAvailableReserveRequest struct {
	BondDid string `protobuf:"bytes,1,opt,name=bond_did,json=bondDid,proto3" json:"bond_did,omitempty"`
}

func (m *QueryAvailableReserveRequest) Reset()         { *m = QueryAvailableReserveRequest{} }
func (m *QueryAvailableReserveRequest) String() string { return proto.CompactTextString(m) }
func (*QueryAvailableReserveRequest) ProtoMessage()    {}
func (*QueryAvailableReserveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{14}
}
func (m *QueryAvailableReserveRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAvailableReserveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAvailableReserveRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAvailableReserveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAvailableReserveRequest.Merge(m, src)
}
func (m *QueryAvailableReserveRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryAvailableReserveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAvailableReserveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAvailableReserveRequest proto.InternalMessageInfo

func (m *QueryAvailableReserveRequest) GetBondDid() string {
	if m != nil {
		return m.BondDid
	}
	return ""
}

// QueryAvailableReserveResponse is the response type for the
// Query/AvailableReserve RPC method.
type QueryAvailableReserveResponse struct {
	AvailableReserve []types.Coin `protobuf:"bytes,1,rep,name=available_reserve,json=availableReserve,proto3" json:"available_reserve"`
}

func (m *QueryAvailableReserveResponse) Reset()         { *m = QueryAvailableReserveResponse{} }
func (m *QueryAvailableReserveResponse) String() string { return proto.CompactTextString(m) }
func (*QueryAvailableReserveResponse) ProtoMessage()    {}
func (*QueryAvailableReserveResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{15}
}
func (m *QueryAvailableReserveResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAvailableReserveResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAvailableReserveResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAvailableReserveResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAvailableReserveResponse.Merge(m, src)
}
func (m *QueryAvailableReserveResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryAvailableReserveResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAvailableReserveResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAvailableReserveResponse proto.InternalMessageInfo

func (m *QueryAvailableReserveResponse) GetAvailableReserve() []types.Coin {
	if m != nil {
		return m.AvailableReserve
	}
	return nil
}

// QueryCustomPriceRequest is the request type for the Query/CustomPrice RPC
// method.
type QueryCustomPriceRequest struct {
	BondDid    string `protobuf:"bytes,1,opt,name=bond_did,json=bondDid,proto3" json:"bond_did,omitempty"`
	BondAmount string `protobuf:"bytes,2,opt,name=bond_amount,json=bondAmount,proto3" json:"bond_amount,omitempty"`
}

func (m *QueryCustomPriceRequest) Reset()         { *m = QueryCustomPriceRequest{} }
func (m *QueryCustomPriceRequest) String() string { return proto.CompactTextString(m) }
func (*QueryCustomPriceRequest) ProtoMessage()    {}
func (*QueryCustomPriceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{16}
}
func (m *QueryCustomPriceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryCustomPriceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryCustomPriceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryCustomPriceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryCustomPriceRequest.Merge(m, src)
}
func (m *QueryCustomPriceRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryCustomPriceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryCustomPriceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryCustomPriceRequest proto.InternalMessageInfo

func (m *QueryCustomPriceRequest) GetBondDid() string {
	if m != nil {
		return m.BondDid
	}
	return ""
}

func (m *QueryCustomPriceRequest) GetBondAmount() string {
	if m != nil {
		return m.BondAmount
	}
	return ""
}

// QueryCustomPriceResponse is the response type for the Query/CustomPrice RPC
// method.
type QueryCustomPriceResponse struct {
	Price github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,1,rep,name=price,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"price"`
}

func (m *QueryCustomPriceResponse) Reset()         { *m = QueryCustomPriceResponse{} }
func (m *QueryCustomPriceResponse) String() string { return proto.CompactTextString(m) }
func (*QueryCustomPriceResponse) ProtoMessage()    {}
func (*QueryCustomPriceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{17}
}
func (m *QueryCustomPriceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryCustomPriceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryCustomPriceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryCustomPriceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryCustomPriceResponse.Merge(m, src)
}
func (m *QueryCustomPriceResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryCustomPriceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryCustomPriceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryCustomPriceResponse proto.InternalMessageInfo

func (m *QueryCustomPriceResponse) GetPrice() github_com_cosmos_cosmos_sdk_types.DecCoins {
	if m != nil {
		return m.Price
	}
	return nil
}

// QueryCustomPriceRequest is the request type for the Query/BuyPrice RPC
// method.
type QueryBuyPriceRequest struct {
	BondDid    string `protobuf:"bytes,1,opt,name=bond_did,json=bondDid,proto3" json:"bond_did,omitempty"`
	BondAmount string `protobuf:"bytes,2,opt,name=bond_amount,json=bondAmount,proto3" json:"bond_amount,omitempty"`
}

func (m *QueryBuyPriceRequest) Reset()         { *m = QueryBuyPriceRequest{} }
func (m *QueryBuyPriceRequest) String() string { return proto.CompactTextString(m) }
func (*QueryBuyPriceRequest) ProtoMessage()    {}
func (*QueryBuyPriceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{18}
}
func (m *QueryBuyPriceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBuyPriceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBuyPriceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBuyPriceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBuyPriceRequest.Merge(m, src)
}
func (m *QueryBuyPriceRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryBuyPriceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBuyPriceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBuyPriceRequest proto.InternalMessageInfo

func (m *QueryBuyPriceRequest) GetBondDid() string {
	if m != nil {
		return m.BondDid
	}
	return ""
}

func (m *QueryBuyPriceRequest) GetBondAmount() string {
	if m != nil {
		return m.BondAmount
	}
	return ""
}

// QueryCustomPriceResponse is the response type for the Query/BuyPrice RPC
// method.
type QueryBuyPriceResponse struct {
	AdjustedSupply types.Coin                               `protobuf:"bytes,1,opt,name=adjusted_supply,json=adjustedSupply,proto3" json:"adjusted_supply"`
	Prices         github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=prices,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"prices"`
	TxFees         github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=tx_fees,json=txFees,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"tx_fees"`
	TotalPrices    github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,4,rep,name=total_prices,json=totalPrices,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_prices"`
	TotalFees      github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,5,rep,name=total_fees,json=totalFees,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_fees"`
}

func (m *QueryBuyPriceResponse) Reset()         { *m = QueryBuyPriceResponse{} }
func (m *QueryBuyPriceResponse) String() string { return proto.CompactTextString(m) }
func (*QueryBuyPriceResponse) ProtoMessage()    {}
func (*QueryBuyPriceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{19}
}
func (m *QueryBuyPriceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBuyPriceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBuyPriceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBuyPriceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBuyPriceResponse.Merge(m, src)
}
func (m *QueryBuyPriceResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryBuyPriceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBuyPriceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBuyPriceResponse proto.InternalMessageInfo

func (m *QueryBuyPriceResponse) GetAdjustedSupply() types.Coin {
	if m != nil {
		return m.AdjustedSupply
	}
	return types.Coin{}
}

func (m *QueryBuyPriceResponse) GetPrices() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Prices
	}
	return nil
}

func (m *QueryBuyPriceResponse) GetTxFees() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TxFees
	}
	return nil
}

func (m *QueryBuyPriceResponse) GetTotalPrices() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalPrices
	}
	return nil
}

func (m *QueryBuyPriceResponse) GetTotalFees() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalFees
	}
	return nil
}

// QuerySellReturnRequest is the request type for the Query/SellReturn RPC
// method.
type QuerySellReturnRequest struct {
	BondDid    string `protobuf:"bytes,1,opt,name=bond_did,json=bondDid,proto3" json:"bond_did,omitempty"`
	BondAmount string `protobuf:"bytes,2,opt,name=bond_amount,json=bondAmount,proto3" json:"bond_amount,omitempty"`
}

func (m *QuerySellReturnRequest) Reset()         { *m = QuerySellReturnRequest{} }
func (m *QuerySellReturnRequest) String() string { return proto.CompactTextString(m) }
func (*QuerySellReturnRequest) ProtoMessage()    {}
func (*QuerySellReturnRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{20}
}
func (m *QuerySellReturnRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySellReturnRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySellReturnRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySellReturnRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySellReturnRequest.Merge(m, src)
}
func (m *QuerySellReturnRequest) XXX_Size() int {
	return m.Size()
}
func (m *QuerySellReturnRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySellReturnRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySellReturnRequest proto.InternalMessageInfo

func (m *QuerySellReturnRequest) GetBondDid() string {
	if m != nil {
		return m.BondDid
	}
	return ""
}

func (m *QuerySellReturnRequest) GetBondAmount() string {
	if m != nil {
		return m.BondAmount
	}
	return ""
}

// QuerySellReturnResponse is the response type for the Query/SellReturn RPC
// method.
type QuerySellReturnResponse struct {
	AdjustedSupply types.Coin                               `protobuf:"bytes,1,opt,name=adjusted_supply,json=adjustedSupply,proto3" json:"adjusted_supply"`
	Returns        github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=returns,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"returns"`
	TxFees         github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=tx_fees,json=txFees,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"tx_fees"`
	ExitFees       github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,4,rep,name=exit_fees,json=exitFees,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"exit_fees"`
	TotalReturns   github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,5,rep,name=total_returns,json=totalReturns,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_returns"`
	TotalFees      github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,6,rep,name=total_fees,json=totalFees,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_fees"`
}

func (m *QuerySellReturnResponse) Reset()         { *m = QuerySellReturnResponse{} }
func (m *QuerySellReturnResponse) String() string { return proto.CompactTextString(m) }
func (*QuerySellReturnResponse) ProtoMessage()    {}
func (*QuerySellReturnResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{21}
}
func (m *QuerySellReturnResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySellReturnResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySellReturnResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySellReturnResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySellReturnResponse.Merge(m, src)
}
func (m *QuerySellReturnResponse) XXX_Size() int {
	return m.Size()
}
func (m *QuerySellReturnResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySellReturnResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySellReturnResponse proto.InternalMessageInfo

func (m *QuerySellReturnResponse) GetAdjustedSupply() types.Coin {
	if m != nil {
		return m.AdjustedSupply
	}
	return types.Coin{}
}

func (m *QuerySellReturnResponse) GetReturns() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Returns
	}
	return nil
}

func (m *QuerySellReturnResponse) GetTxFees() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TxFees
	}
	return nil
}

func (m *QuerySellReturnResponse) GetExitFees() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.ExitFees
	}
	return nil
}

func (m *QuerySellReturnResponse) GetTotalReturns() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalReturns
	}
	return nil
}

func (m *QuerySellReturnResponse) GetTotalFees() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalFees
	}
	return nil
}

// QuerySwapReturnRequest is the request type for the Query/SwapReturn RPC
// method.
type QuerySwapReturnRequest struct {
	BondDid             string `protobuf:"bytes,1,opt,name=bond_did,json=bondDid,proto3" json:"bond_did,omitempty"`
	FromTokenWithAmount string `protobuf:"bytes,2,opt,name=from_token_with_amount,json=fromTokenWithAmount,proto3" json:"from_token_with_amount,omitempty"`
	ToToken             string `protobuf:"bytes,3,opt,name=to_token,json=toToken,proto3" json:"to_token,omitempty"`
}

func (m *QuerySwapReturnRequest) Reset()         { *m = QuerySwapReturnRequest{} }
func (m *QuerySwapReturnRequest) String() string { return proto.CompactTextString(m) }
func (*QuerySwapReturnRequest) ProtoMessage()    {}
func (*QuerySwapReturnRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{22}
}
func (m *QuerySwapReturnRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySwapReturnRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySwapReturnRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySwapReturnRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySwapReturnRequest.Merge(m, src)
}
func (m *QuerySwapReturnRequest) XXX_Size() int {
	return m.Size()
}
func (m *QuerySwapReturnRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySwapReturnRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySwapReturnRequest proto.InternalMessageInfo

func (m *QuerySwapReturnRequest) GetBondDid() string {
	if m != nil {
		return m.BondDid
	}
	return ""
}

func (m *QuerySwapReturnRequest) GetFromTokenWithAmount() string {
	if m != nil {
		return m.FromTokenWithAmount
	}
	return ""
}

func (m *QuerySwapReturnRequest) GetToToken() string {
	if m != nil {
		return m.ToToken
	}
	return ""
}

// QuerySwapReturnResponse is the response type for the Query/SwapReturn RPC
// method.
type QuerySwapReturnResponse struct {
	TotalReturns github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=total_returns,json=totalReturns,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_returns"`
	TotalFees    github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=total_fees,json=totalFees,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_fees"`
}

func (m *QuerySwapReturnResponse) Reset()         { *m = QuerySwapReturnResponse{} }
func (m *QuerySwapReturnResponse) String() string { return proto.CompactTextString(m) }
func (*QuerySwapReturnResponse) ProtoMessage()    {}
func (*QuerySwapReturnResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{23}
}
func (m *QuerySwapReturnResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySwapReturnResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySwapReturnResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySwapReturnResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySwapReturnResponse.Merge(m, src)
}
func (m *QuerySwapReturnResponse) XXX_Size() int {
	return m.Size()
}
func (m *QuerySwapReturnResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySwapReturnResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySwapReturnResponse proto.InternalMessageInfo

func (m *QuerySwapReturnResponse) GetTotalReturns() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalReturns
	}
	return nil
}

func (m *QuerySwapReturnResponse) GetTotalFees() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalFees
	}
	return nil
}

// QueryAlphaMaximumsRequest is the request type for the Query/AlphaMaximums RPC
// method.
type QueryAlphaMaximumsRequest struct {
	BondDid string `protobuf:"bytes,1,opt,name=bond_did,json=bondDid,proto3" json:"bond_did,omitempty"`
}

func (m *QueryAlphaMaximumsRequest) Reset()         { *m = QueryAlphaMaximumsRequest{} }
func (m *QueryAlphaMaximumsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryAlphaMaximumsRequest) ProtoMessage()    {}
func (*QueryAlphaMaximumsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{24}
}
func (m *QueryAlphaMaximumsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAlphaMaximumsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAlphaMaximumsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAlphaMaximumsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAlphaMaximumsRequest.Merge(m, src)
}
func (m *QueryAlphaMaximumsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryAlphaMaximumsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAlphaMaximumsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAlphaMaximumsRequest proto.InternalMessageInfo

func (m *QueryAlphaMaximumsRequest) GetBondDid() string {
	if m != nil {
		return m.BondDid
	}
	return ""
}

// QueryAlphaMaximumsResponse is the response type for the Query/AlphaMaximums
// RPC method.
type QueryAlphaMaximumsResponse struct {
	MaxSystemAlphaIncrease cosmossdk_io_math.LegacyDec `protobuf:"bytes,1,opt,name=max_system_alpha_increase,json=maxSystemAlphaIncrease,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"max_system_alpha_increase"`
	MaxSystemAlpha         cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=max_system_alpha,json=maxSystemAlpha,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"max_system_alpha"`
}

func (m *QueryAlphaMaximumsResponse) Reset()         { *m = QueryAlphaMaximumsResponse{} }
func (m *QueryAlphaMaximumsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryAlphaMaximumsResponse) ProtoMessage()    {}
func (*QueryAlphaMaximumsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{25}
}
func (m *QueryAlphaMaximumsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAlphaMaximumsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAlphaMaximumsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAlphaMaximumsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAlphaMaximumsResponse.Merge(m, src)
}
func (m *QueryAlphaMaximumsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryAlphaMaximumsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAlphaMaximumsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAlphaMaximumsResponse proto.InternalMessageInfo

// QueryParamsRequest is the request type for the Query/Params RPC method.
type QueryParamsRequest struct {
}

func (m *QueryParamsRequest) Reset()         { *m = QueryParamsRequest{} }
func (m *QueryParamsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryParamsRequest) ProtoMessage()    {}
func (*QueryParamsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{26}
}
func (m *QueryParamsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryParamsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryParamsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryParamsRequest.Merge(m, src)
}
func (m *QueryParamsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryParamsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryParamsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryParamsRequest proto.InternalMessageInfo

// QueryParamsResponse is the response type for the Query/Params RPC method.
type QueryParamsResponse struct {
	Params *Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params,omitempty"`
}

func (m *QueryParamsResponse) Reset()         { *m = QueryParamsResponse{} }
func (m *QueryParamsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryParamsResponse) ProtoMessage()    {}
func (*QueryParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fa71bc30097837d, []int{27}
}
func (m *QueryParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryParamsResponse.Merge(m, src)
}
func (m *QueryParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryParamsResponse proto.InternalMessageInfo

func (m *QueryParamsResponse) GetParams() *Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func init() {
	proto.RegisterType((*QueryBondsRequest)(nil), "ixo.bonds.v1beta1.QueryBondsRequest")
	proto.RegisterType((*QueryBondsResponse)(nil), "ixo.bonds.v1beta1.QueryBondsResponse")
	proto.RegisterType((*QueryBondsDetailedRequest)(nil), "ixo.bonds.v1beta1.QueryBondsDetailedRequest")
	proto.RegisterType((*QueryBondsDetailedResponse)(nil), "ixo.bonds.v1beta1.QueryBondsDetailedResponse")
	proto.RegisterType((*QueryBondRequest)(nil), "ixo.bonds.v1beta1.QueryBondRequest")
	proto.RegisterType((*QueryBondResponse)(nil), "ixo.bonds.v1beta1.QueryBondResponse")
	proto.RegisterType((*QueryBatchRequest)(nil), "ixo.bonds.v1beta1.QueryBatchRequest")
	proto.RegisterType((*QueryBatchResponse)(nil), "ixo.bonds.v1beta1.QueryBatchResponse")
	proto.RegisterType((*QueryLastBatchRequest)(nil), "ixo.bonds.v1beta1.QueryLastBatchRequest")
	proto.RegisterType((*QueryLastBatchResponse)(nil), "ixo.bonds.v1beta1.QueryLastBatchResponse")
	proto.RegisterType((*QueryCurrentPriceRequest)(nil), "ixo.bonds.v1beta1.QueryCurrentPriceRequest")
	proto.RegisterType((*QueryCurrentPriceResponse)(nil), "ixo.bonds.v1beta1.QueryCurrentPriceResponse")
	proto.RegisterType((*QueryCurrentReserveRequest)(nil), "ixo.bonds.v1beta1.QueryCurrentReserveRequest")
	proto.RegisterType((*QueryCurrentReserveResponse)(nil), "ixo.bonds.v1beta1.QueryCurrentReserveResponse")
	proto.RegisterType((*QueryAvailableReserveRequest)(nil), "ixo.bonds.v1beta1.QueryAvailableReserveRequest")
	proto.RegisterType((*QueryAvailableReserveResponse)(nil), "ixo.bonds.v1beta1.QueryAvailableReserveResponse")
	proto.RegisterType((*QueryCustomPriceRequest)(nil), "ixo.bonds.v1beta1.QueryCustomPriceRequest")
	proto.RegisterType((*QueryCustomPriceResponse)(nil), "ixo.bonds.v1beta1.QueryCustomPriceResponse")
	proto.RegisterType((*QueryBuyPriceRequest)(nil), "ixo.bonds.v1beta1.QueryBuyPriceRequest")
	proto.RegisterType((*QueryBuyPriceResponse)(nil), "ixo.bonds.v1beta1.QueryBuyPriceResponse")
	proto.RegisterType((*QuerySellReturnRequest)(nil), "ixo.bonds.v1beta1.QuerySellReturnRequest")
	proto.RegisterType((*QuerySellReturnResponse)(nil), "ixo.bonds.v1beta1.QuerySellReturnResponse")
	proto.RegisterType((*QuerySwapReturnRequest)(nil), "ixo.bonds.v1beta1.QuerySwapReturnRequest")
	proto.RegisterType((*QuerySwapReturnResponse)(nil), "ixo.bonds.v1beta1.QuerySwapReturnResponse")
	proto.RegisterType((*QueryAlphaMaximumsRequest)(nil), "ixo.bonds.v1beta1.QueryAlphaMaximumsRequest")
	proto.RegisterType((*QueryAlphaMaximumsResponse)(nil), "ixo.bonds.v1beta1.QueryAlphaMaximumsResponse")
	proto.RegisterType((*QueryParamsRequest)(nil), "ixo.bonds.v1beta1.QueryParamsRequest")
	proto.RegisterType((*QueryParamsResponse)(nil), "ixo.bonds.v1beta1.QueryParamsResponse")
}

func init() { proto.RegisterFile("ixo/bonds/v1beta1/query.proto", fileDescriptor_7fa71bc30097837d) }

var fileDescriptor_7fa71bc30097837d = []byte{
	// 1482 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0xcf, 0x6f, 0x13, 0x57,
	0x10, 0xce, 0x86, 0x38, 0x90, 0x09, 0x09, 0xc9, 0x4b, 0x00, 0xdb, 0x21, 0x0e, 0x5d, 0x7e, 0x05,
	0x82, 0xbd, 0x24, 0x94, 0xd2, 0xde, 0x4a, 0x08, 0x2d, 0x95, 0x40, 0x02, 0x43, 0x55, 0xa9, 0x3d,
	0xac, 0x9e, 0xd7, 0x0f, 0x7b, 0xc9, 0x7a, 0x9f, 0xf1, 0x3e, 0x07, 0x5b, 0x28, 0x97, 0x72, 0xa9,
	0x7a, 0x69, 0x25, 0xaa, 0x4a, 0xad, 0xaa, 0x1e, 0x7b, 0xe8, 0xb1, 0xea, 0x1f, 0xc1, 0x11, 0xb5,
	0x97, 0xaa, 0x07, 0x5a, 0x41, 0xa5, 0xfe, 0x09, 0xed, 0xa9, 0xaa, 0xf6, 0xbd, 0x59, 0x67, 0x6d,
	0xef, 0x3a, 0xdb, 0x2a, 0xe6, 0x02, 0xd9, 0x37, 0x33, 0xdf, 0xf7, 0xcd, 0xec, 0x3c, 0x7b, 0xc6,
	0xb0, 0x68, 0xb7, 0xb8, 0x51, 0xe2, 0x6e, 0xd9, 0x33, 0xb6, 0x56, 0x4b, 0x4c, 0xd0, 0x55, 0xe3,
	0x41, 0x93, 0x35, 0xda, 0x85, 0x7a, 0x83, 0x0b, 0x4e, 0x66, 0xed, 0x16, 0x2f, 0x48, 0x73, 0x01,
	0xcd, 0xd9, 0xf9, 0x0a, 0xaf, 0x70, 0x69, 0x35, 0xfc, 0xbf, 0x94, 0x63, 0xf6, 0x58, 0x85, 0xf3,
	0x8a, 0xc3, 0x0c, 0x5a, 0xb7, 0x0d, 0xea, 0xba, 0x5c, 0x50, 0x61, 0x73, 0xd7, 0x43, 0x6b, 0xce,
	0xe2, 0x5e, 0x8d, 0x7b, 0x46, 0x89, 0x7a, 0xac, 0xc3, 0x63, 0x71, 0xdb, 0x45, 0x7b, 0x46, 0xd9,
	0x4d, 0x05, 0xab, 0x1e, 0xd0, 0x14, 0x21, 0x50, 0xe9, 0x91, 0x66, 0x7d, 0x0e, 0x66, 0x6f, 0xfb,
	0x7a, 0xd7, 0xfd, 0xb3, 0x22, 0x7b, 0xd0, 0x64, 0x9e, 0xd0, 0xcf, 0x01, 0x09, 0x1f, 0x7a, 0x75,
	0xee, 0x7a, 0x8c, 0xcc, 0x43, 0x4a, 0x46, 0xa6, 0xb5, 0xe3, 0xfb, 0x96, 0x27, 0x8a, 0xea, 0x41,
	0x5f, 0x80, 0xcc, 0x8e, 0xef, 0x06, 0x13, 0xd4, 0x76, 0x58, 0x39, 0x00, 0xb2, 0x20, 0x1b, 0x65,
	0x44, 0xc0, 0x6b, 0x30, 0x2d, 0x31, 0xcc, 0x32, 0x5a, 0x24, 0xf2, 0xe4, 0x5a, 0xae, 0xd0, 0x57,
	0xb5, 0x82, 0x8f, 0xa0, 0x00, 0xbc, 0xe2, 0x54, 0x29, 0x0c, 0xa7, 0xe7, 0x61, 0xa6, 0x43, 0x82,
	0xc4, 0x24, 0x03, 0x07, 0x7c, 0x27, 0xb3, 0x6c, 0xfb, 0xa0, 0xda, 0xf2, 0x44, 0x71, 0xbf, 0xff,
	0xbc, 0x61, 0x97, 0xf5, 0xb7, 0x43, 0x19, 0x77, 0xa4, 0xac, 0xc0, 0x98, 0x6f, 0x97, 0xbe, 0x93,
	0x6b, 0x47, 0x63, 0x04, 0x14, 0xa5, 0x93, 0x5e, 0x08, 0x10, 0xa8, 0xb0, 0xaa, 0x09, 0x18, 0x37,
	0x82, 0x72, 0x2a, 0x7f, 0xa4, 0x2c, 0x40, 0xaa, 0xe4, 0x1f, 0x20, 0x67, 0x3a, 0x8a, 0x53, 0x06,
	0x28, 0x37, 0x7d, 0x0d, 0x0e, 0x4b, 0x94, 0x1b, 0xd4, 0x13, 0x49, 0x99, 0x6f, 0xc3, 0x91, 0xde,
	0x18, 0x64, 0xbf, 0x0c, 0xe0, 0x50, 0x4f, 0x98, 0xc9, 0x24, 0x4c, 0x38, 0x01, 0x80, 0x7e, 0x09,
	0xd2, 0x12, 0xf2, 0x6a, 0xb3, 0xd1, 0x60, 0xae, 0xb8, 0xd5, 0xb0, 0x2d, 0x96, 0x40, 0xc9, 0x13,
	0x0d, 0xfb, 0xa4, 0x3b, 0x0e, 0xd5, 0x6c, 0xc1, 0x94, 0xa5, 0xce, 0xcd, 0xba, 0x6f, 0xc0, 0x46,
	0x38, 0x56, 0xc0, 0x56, 0xf6, 0xfb, 0xbe, 0x23, 0x69, 0x83, 0x59, 0x57, 0xb9, 0xed, 0xae, 0x5f,
	0x7c, 0xfa, 0x7c, 0x69, 0xe4, 0xfb, 0xdf, 0x96, 0x56, 0x2a, 0xb6, 0xa8, 0x36, 0x4b, 0x05, 0x8b,
	0xd7, 0xb0, 0xf5, 0xf1, 0xbf, 0xbc, 0x57, 0xde, 0x34, 0x44, 0xbb, 0xce, 0xbc, 0x20, 0xc6, 0x2b,
	0x1e, 0xb4, 0x42, 0xfc, 0xfa, 0x65, 0xec, 0x4f, 0x14, 0x55, 0x64, 0x1e, 0x6b, 0x6c, 0x25, 0x49,
	0xa7, 0x02, 0x0b, 0x91, 0x81, 0x98, 0xcf, 0x75, 0x38, 0x14, 0xe4, 0xd3, 0x50, 0x26, 0xcc, 0x28,
	0x13, 0x99, 0x91, 0x4c, 0x67, 0xcc, 0x4f, 0xa7, 0x38, 0x6d, 0x75, 0x21, 0xea, 0x6f, 0xc1, 0x31,
	0x49, 0x74, 0x65, 0x8b, 0xda, 0x0e, 0x2d, 0x39, 0x2c, 0xb9, 0xc6, 0x1a, 0x2c, 0xc6, 0x84, 0xa2,
	0xca, 0x1b, 0x30, 0x4b, 0x03, 0xdb, 0x7f, 0xd5, 0x39, 0x43, 0x7b, 0x50, 0xf5, 0xf7, 0xe1, 0x28,
	0x96, 0xc4, 0x13, 0xbc, 0x96, 0xb0, 0x2f, 0xc8, 0x12, 0x4c, 0x4a, 0x13, 0xad, 0xf1, 0xa6, 0x2b,
	0xd2, 0xa3, 0xd2, 0x0a, 0xfe, 0xd1, 0x15, 0x79, 0xa2, 0x3f, 0xd6, 0x3a, 0x0d, 0x17, 0xc2, 0xc5,
	0x0c, 0x2a, 0x90, 0x1a, 0x72, 0xbf, 0x28, 0x7c, 0xbd, 0x08, 0xf3, 0xea, 0x0a, 0x37, 0xdb, 0x7b,
	0x96, 0xd9, 0x27, 0x63, 0x78, 0xa3, 0x77, 0x40, 0x77, 0xda, 0x87, 0x96, 0xef, 0x37, 0x3d, 0xc1,
	0xca, 0xa6, 0xd7, 0xac, 0xd7, 0x9d, 0x36, 0xde, 0xd0, 0xdd, 0xdb, 0x27, 0x88, 0xbb, 0x23, 0xc3,
	0x88, 0x05, 0xe3, 0x32, 0x01, 0x2f, 0x3d, 0xba, 0xdb, 0x7b, 0xbd, 0x80, 0xe5, 0x59, 0x4e, 0x50,
	0x1e, 0x55, 0x1b, 0x84, 0x26, 0x65, 0xd8, 0x2f, 0x5a, 0xe6, 0x3d, 0xc6, 0xbc, 0xf4, 0xbe, 0x21,
	0xb0, 0x88, 0xd6, 0x3b, 0x8c, 0x79, 0xc4, 0x85, 0x83, 0x82, 0x0b, 0xea, 0x98, 0x98, 0xd0, 0xd8,
	0xde, 0x53, 0x4d, 0x4a, 0x82, 0x5b, 0x2a, 0xab, 0xfb, 0x00, 0x8a, 0x4f, 0x26, 0x96, 0xda, 0x7b,
	0xb6, 0x09, 0x09, 0xef, 0xe7, 0xa6, 0xdf, 0xc5, 0xcf, 0xe9, 0x3b, 0xcc, 0x71, 0x8a, 0x4c, 0x34,
	0x1b, 0xee, 0x5e, 0x34, 0xd8, 0xdf, 0x63, 0x78, 0x25, 0xc3, 0xb0, 0x7b, 0xde, 0x62, 0x0c, 0xf6,
	0x37, 0x24, 0xf6, 0x50, 0x7a, 0x2c, 0xc0, 0x7e, 0x45, 0x4d, 0x56, 0x85, 0x09, 0xd6, 0xb2, 0x85,
	0xe2, 0x19, 0x42, 0x87, 0x1d, 0xf0, 0xd1, 0x25, 0x53, 0x1d, 0xa6, 0x54, 0x7b, 0x05, 0xc5, 0x1b,
	0x42, 0x87, 0xa9, 0x0b, 0x53, 0xc4, 0x0a, 0x76, 0x37, 0xf4, 0xf8, 0x50, 0x1b, 0xfa, 0xb1, 0x16,
	0x74, 0xf4, 0x43, 0x5a, 0x4f, 0xdc, 0xd1, 0x17, 0xe1, 0xc8, 0xbd, 0x06, 0xaf, 0x99, 0x82, 0x6f,
	0x32, 0xd7, 0x7c, 0x68, 0x8b, 0x6a, 0x77, 0x73, 0xcf, 0xf9, 0xd6, 0xbb, 0xbe, 0xf1, 0x03, 0x5b,
	0x54, 0x55, 0x97, 0xfb, 0x78, 0x82, 0xab, 0x90, 0xf4, 0x3e, 0x85, 0x27, 0xb8, 0x74, 0xd2, 0xff,
	0xd2, 0x82, 0x0b, 0x10, 0x52, 0x81, 0x17, 0xa0, 0xaf, 0xfe, 0xda, 0xab, 0xad, 0xff, 0xe8, 0x50,
	0xeb, 0xff, 0x06, 0x4e, 0x5b, 0x57, 0x9c, 0x7a, 0x95, 0xde, 0xa4, 0x2d, 0xbb, 0xd6, 0xac, 0x79,
	0x09, 0x66, 0x86, 0x3f, 0x35, 0x9c, 0x88, 0x7a, 0x02, 0xb1, 0x68, 0x0e, 0x64, 0x6a, 0xb4, 0x65,
	0x7a, 0x6d, 0x4f, 0xb0, 0x9a, 0x49, 0x7d, 0x1f, 0xd3, 0x76, 0xad, 0x06, 0xa3, 0x1e, 0x53, 0x50,
	0xeb, 0xab, 0xbe, 0xec, 0x5f, 0x9f, 0x2f, 0x2d, 0x28, 0x91, 0x5e, 0x79, 0xb3, 0x60, 0x73, 0xa3,
	0x46, 0x45, 0xb5, 0x70, 0x83, 0x55, 0xa8, 0xd5, 0xde, 0x60, 0xd6, 0x4f, 0x3f, 0xe6, 0x01, 0xf3,
	0xde, 0x60, 0x56, 0xf1, 0x48, 0x8d, 0xb6, 0xee, 0x48, 0x48, 0xc9, 0xfa, 0x1e, 0x02, 0x92, 0x8f,
	0x60, 0xa6, 0x97, 0x4d, 0x35, 0xc2, 0xff, 0x21, 0x99, 0xee, 0x26, 0xd1, 0xe7, 0x71, 0x28, 0xbf,
	0x45, 0x1b, 0xb4, 0x53, 0x1a, 0xfd, 0x3a, 0xcc, 0x75, 0x9d, 0x62, 0xde, 0xab, 0x30, 0x5e, 0x97,
	0x27, 0x9d, 0x0f, 0xc9, 0xfe, 0x49, 0x19, 0x43, 0xd0, 0x71, 0xed, 0x9f, 0x43, 0x90, 0x92, 0x50,
	0xc4, 0x85, 0x94, 0xdc, 0x7f, 0xc8, 0xc9, 0x88, 0xa8, 0xbe, 0xe5, 0x2b, 0x7b, 0x6a, 0x17, 0x2f,
	0x25, 0x49, 0x4f, 0x7f, 0xfc, 0xf3, 0x1f, 0x4f, 0x46, 0x09, 0x99, 0x31, 0x76, 0x16, 0x3c, 0xf9,
	0x2f, 0xf9, 0x4c, 0x83, 0xa9, 0xae, 0x85, 0x8b, 0x9c, 0x1f, 0x08, 0xd9, 0xb3, 0xb4, 0x65, 0xf3,
	0x09, 0xbd, 0x51, 0xc8, 0x6b, 0x52, 0xc8, 0x02, 0xc9, 0xf4, 0x0a, 0xe9, 0xac, 0x75, 0xa4, 0x01,
	0xe3, 0xaa, 0x3a, 0x24, 0x36, 0xb9, 0xae, 0xd7, 0x90, 0x3d, 0xbd, 0x9b, 0x1b, 0x72, 0x67, 0x24,
	0xf7, 0x1c, 0x99, 0x0d, 0x71, 0xab, 0xfa, 0x93, 0x3a, 0x8c, 0xf9, 0x7a, 0xc9, 0x89, 0x41, 0xd9,
	0x04, 0x7c, 0x27, 0x07, 0x3b, 0x21, 0xdb, 0xa2, 0x64, 0x3b, 0x4a, 0x0e, 0x87, 0xd8, 0x1e, 0x05,
	0x37, 0x69, 0x9b, 0xb4, 0x21, 0x25, 0x57, 0xa4, 0x01, 0xef, 0x39, 0xb4, 0xb6, 0x0d, 0x78, 0xcf,
	0xe1, 0x45, 0x4d, 0x3f, 0x21, 0x49, 0x17, 0xc9, 0x42, 0x24, 0xa9, 0x21, 0xf7, 0x37, 0xf2, 0xa9,
	0x06, 0x13, 0x9d, 0x1d, 0x8f, 0x2c, 0xc7, 0x21, 0xf7, 0xae, 0x8e, 0xd9, 0xb3, 0x09, 0x3c, 0x51,
	0xc7, 0xb2, 0xd4, 0xa1, 0x93, 0xe3, 0xd1, 0x3a, 0x76, 0x96, 0x49, 0xf2, 0xa5, 0x06, 0x07, 0xc3,
	0x5b, 0x1e, 0x59, 0x89, 0x63, 0x89, 0xd8, 0x21, 0xb3, 0xe7, 0x93, 0x39, 0xa3, 0xaa, 0x15, 0xa9,
	0xea, 0x14, 0x39, 0x11, 0xad, 0xaa, 0x6b, 0xa9, 0x24, 0xdf, 0x6a, 0x30, 0xdd, 0xbd, 0xb0, 0x91,
	0xfc, 0x2e, 0x6c, 0xdd, 0xdb, 0x56, 0xb6, 0x90, 0xd4, 0x1d, 0xe5, 0xe5, 0xa5, 0xbc, 0x33, 0xe4,
	0xd4, 0x60, 0x79, 0xb8, 0x7b, 0x91, 0xef, 0x34, 0x98, 0xe9, 0xdd, 0xd6, 0x88, 0x11, 0xc7, 0x19,
	0xb3, 0x12, 0x66, 0x2f, 0x24, 0x0f, 0x40, 0x99, 0x86, 0x94, 0x79, 0x96, 0x9c, 0x89, 0x96, 0xd9,
	0xb7, 0x24, 0x92, 0xaf, 0x34, 0x98, 0x0c, 0xed, 0x63, 0xe4, 0x5c, 0x7c, 0x5d, 0x7a, 0x97, 0xc1,
	0xec, 0x4a, 0x22, 0x5f, 0x54, 0xb6, 0x2a, 0x95, 0xad, 0x90, 0xb3, 0xd1, 0xca, 0xe4, 0x7b, 0xc5,
	0x03, 0x35, 0x29, 0x6c, 0x93, 0x2f, 0x34, 0x38, 0x10, 0x6c, 0x54, 0xe4, 0x4c, 0xec, 0x25, 0xeb,
	0x5e, 0xe4, 0xb2, 0xcb, 0xbb, 0x3b, 0xa2, 0xa4, 0x4b, 0x52, 0x92, 0x41, 0xf2, 0x31, 0x17, 0xb2,
	0xd9, 0x36, 0xa3, 0x64, 0x7d, 0xa3, 0x01, 0xec, 0xcc, 0xe1, 0x24, 0xf6, 0xe6, 0xf5, 0xad, 0x00,
	0xd9, 0x73, 0x49, 0x5c, 0x51, 0xdc, 0x65, 0x29, 0x6e, 0x95, 0x18, 0xd1, 0xe2, 0x3c, 0xe6, 0x04,
	0x03, 0x4f, 0x8f, 0xbc, 0x1f, 0x7c, 0x79, 0x9d, 0x29, 0x69, 0x80, 0xbc, 0xde, 0x79, 0x6e, 0x80,
	0xbc, 0xbe, 0xa1, 0x4b, 0xbf, 0x29, 0xe5, 0xbd, 0x4b, 0xae, 0xc5, 0xc8, 0x7b, 0x48, 0xeb, 0x1d,
	0x79, 0xd1, 0x93, 0xe0, 0xb6, 0xf1, 0x28, 0x98, 0xf6, 0xb6, 0xc9, 0xd7, 0x1a, 0x4c, 0x75, 0x0d,
	0x2a, 0xf1, 0xdf, 0x74, 0x51, 0x83, 0x50, 0xfc, 0x37, 0x5d, 0xe4, 0xf4, 0xa3, 0x9f, 0x97, 0xea,
	0x4f, 0x93, 0x93, 0x31, 0xd7, 0x44, 0x8e, 0x43, 0x35, 0x8c, 0x5a, 0x2f, 0x3e, 0x7d, 0x91, 0xd3,
	0x9e, 0xbd, 0xc8, 0x69, 0xbf, 0xbf, 0xc8, 0x69, 0x9f, 0xbf, 0xcc, 0x8d, 0x3c, 0x7b, 0x99, 0x1b,
	0xf9, 0xe5, 0x65, 0x6e, 0xe4, 0xc3, 0x37, 0x43, 0x13, 0x9d, 0xdd, 0xe2, 0xf7, 0x78, 0xd3, 0x2d,
	0xcb, 0x9f, 0x7b, 0xfd, 0xa7, 0x7c, 0xc9, 0xe1, 0xd6, 0xa6, 0x55, 0xa5, 0xb6, 0x6b, 0x6c, 0xbd,
	0x6e, 0xb4, 0x90, 0x47, 0xce, 0x79, 0xa5, 0x71, 0xf9, 0xa3, 0xed, 0xc5, 0x7f, 0x03, 0x00, 0x00,
	0xff, 0xff, 0xde, 0x3f, 0xbf, 0x29, 0x76, 0x16, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	// Bonds returns all existing bonds.
	Bonds(ctx context.Context, in *QueryBondsRequest, opts ...grpc.CallOption) (*QueryBondsResponse, error)
	// BondsDetailed returns a list of all existing bonds with some details about
	// their current state.
	BondsDetailed(ctx context.Context, in *QueryBondsDetailedRequest, opts ...grpc.CallOption) (*QueryBondsDetailedResponse, error)
	// Params queries the parameters of x/bonds module.
	Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error)
	// Bond queries info of a specific bond.
	Bond(ctx context.Context, in *QueryBondRequest, opts ...grpc.CallOption) (*QueryBondResponse, error)
	// Batch queries info of a specific bond's current batch.
	Batch(ctx context.Context, in *QueryBatchRequest, opts ...grpc.CallOption) (*QueryBatchResponse, error)
	// LastBatch queries info of a specific bond's last batch.
	LastBatch(ctx context.Context, in *QueryLastBatchRequest, opts ...grpc.CallOption) (*QueryLastBatchResponse, error)
	// CurrentPrice queries the current price/s of a specific bond.
	CurrentPrice(ctx context.Context, in *QueryCurrentPriceRequest, opts ...grpc.CallOption) (*QueryCurrentPriceResponse, error)
	// CurrentReserve queries the current balance/s of the reserve pool for a
	// specific bond.
	CurrentReserve(ctx context.Context, in *QueryCurrentReserveRequest, opts ...grpc.CallOption) (*QueryCurrentReserveResponse, error)
	// AvailableReserve queries current available balance/s of the reserve pool
	// for a specific bond.
	AvailableReserve(ctx context.Context, in *QueryAvailableReserveRequest, opts ...grpc.CallOption) (*QueryAvailableReserveResponse, error)
	// CustomPrice queries price/s of a specific bond at a specific supply.
	CustomPrice(ctx context.Context, in *QueryCustomPriceRequest, opts ...grpc.CallOption) (*QueryCustomPriceResponse, error)
	// BuyPrice queries price/s of buying an amount of tokens from a specific
	// bond.
	BuyPrice(ctx context.Context, in *QueryBuyPriceRequest, opts ...grpc.CallOption) (*QueryBuyPriceResponse, error)
	// SellReturn queries return/s on selling an amount of tokens of a specific
	// bond.
	SellReturn(ctx context.Context, in *QuerySellReturnRequest, opts ...grpc.CallOption) (*QuerySellReturnResponse, error)
	// SwapReturn queries return/s on swapping an amount of tokens to another
	// token of a specific bond.
	SwapReturn(ctx context.Context, in *QuerySwapReturnRequest, opts ...grpc.CallOption) (*QuerySwapReturnResponse, error)
	// AlphaMaximums queries alpha maximums for a specific augmented bonding
	// curve.
	AlphaMaximums(ctx context.Context, in *QueryAlphaMaximumsRequest, opts ...grpc.CallOption) (*QueryAlphaMaximumsResponse, error)
}

type queryClient struct {
	cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Bonds(ctx context.Context, in *QueryBondsRequest, opts ...grpc.CallOption) (*QueryBondsResponse, error) {
	out := new(QueryBondsResponse)
	err := c.cc.Invoke(ctx, "/ixo.bonds.v1beta1.Query/Bonds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) BondsDetailed(ctx context.Context, in *QueryBondsDetailedRequest, opts ...grpc.CallOption) (*QueryBondsDetailedResponse, error) {
	out := new(QueryBondsDetailedResponse)
	err := c.cc.Invoke(ctx, "/ixo.bonds.v1beta1.Query/BondsDetailed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error) {
	out := new(QueryParamsResponse)
	err := c.cc.Invoke(ctx, "/ixo.bonds.v1beta1.Query/Params", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Bond(ctx context.Context, in *QueryBondRequest, opts ...grpc.CallOption) (*QueryBondResponse, error) {
	out := new(QueryBondResponse)
	err := c.cc.Invoke(ctx, "/ixo.bonds.v1beta1.Query/Bond", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Batch(ctx context.Context, in *QueryBatchRequest, opts ...grpc.CallOption) (*QueryBatchResponse, error) {
	out := new(QueryBatchResponse)
	err := c.cc.Invoke(ctx, "/ixo.bonds.v1beta1.Query/Batch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) LastBatch(ctx context.Context, in *QueryLastBatchRequest, opts ...grpc.CallOption) (*QueryLastBatchResponse, error) {
	out := new(QueryLastBatchResponse)
	err := c.cc.Invoke(ctx, "/ixo.bonds.v1beta1.Query/LastBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) CurrentPrice(ctx context.Context, in *QueryCurrentPriceRequest, opts ...grpc.CallOption) (*QueryCurrentPriceResponse, error) {
	out := new(QueryCurrentPriceResponse)
	err := c.cc.Invoke(ctx, "/ixo.bonds.v1beta1.Query/CurrentPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) CurrentReserve(ctx context.Context, in *QueryCurrentReserveRequest, opts ...grpc.CallOption) (*QueryCurrentReserveResponse, error) {
	out := new(QueryCurrentReserveResponse)
	err := c.cc.Invoke(ctx, "/ixo.bonds.v1beta1.Query/CurrentReserve", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AvailableReserve(ctx context.Context, in *QueryAvailableReserveRequest, opts ...grpc.CallOption) (*QueryAvailableReserveResponse, error) {
	out := new(QueryAvailableReserveResponse)
	err := c.cc.Invoke(ctx, "/ixo.bonds.v1beta1.Query/AvailableReserve", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) CustomPrice(ctx context.Context, in *QueryCustomPriceRequest, opts ...grpc.CallOption) (*QueryCustomPriceResponse, error) {
	out := new(QueryCustomPriceResponse)
	err := c.cc.Invoke(ctx, "/ixo.bonds.v1beta1.Query/CustomPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) BuyPrice(ctx context.Context, in *QueryBuyPriceRequest, opts ...grpc.CallOption) (*QueryBuyPriceResponse, error) {
	out := new(QueryBuyPriceResponse)
	err := c.cc.Invoke(ctx, "/ixo.bonds.v1beta1.Query/BuyPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) SellReturn(ctx context.Context, in *QuerySellReturnRequest, opts ...grpc.CallOption) (*QuerySellReturnResponse, error) {
	out := new(QuerySellReturnResponse)
	err := c.cc.Invoke(ctx, "/ixo.bonds.v1beta1.Query/SellReturn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) SwapReturn(ctx context.Context, in *QuerySwapReturnRequest, opts ...grpc.CallOption) (*QuerySwapReturnResponse, error) {
	out := new(QuerySwapReturnResponse)
	err := c.cc.Invoke(ctx, "/ixo.bonds.v1beta1.Query/SwapReturn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AlphaMaximums(ctx context.Context, in *QueryAlphaMaximumsRequest, opts ...grpc.CallOption) (*QueryAlphaMaximumsResponse, error) {
	out := new(QueryAlphaMaximumsResponse)
	err := c.cc.Invoke(ctx, "/ixo.bonds.v1beta1.Query/AlphaMaximums", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	// Bonds returns all existing bonds.
	Bonds(context.Context, *QueryBondsRequest) (*QueryBondsResponse, error)
	// BondsDetailed returns a list of all existing bonds with some details about
	// their current state.
	BondsDetailed(context.Context, *QueryBondsDetailedRequest) (*QueryBondsDetailedResponse, error)
	// Params queries the parameters of x/bonds module.
	Params(context.Context, *QueryParamsRequest) (*QueryParamsResponse, error)
	// Bond queries info of a specific bond.
	Bond(context.Context, *QueryBondRequest) (*QueryBondResponse, error)
	// Batch queries info of a specific bond's current batch.
	Batch(context.Context, *QueryBatchRequest) (*QueryBatchResponse, error)
	// LastBatch queries info of a specific bond's last batch.
	LastBatch(context.Context, *QueryLastBatchRequest) (*QueryLastBatchResponse, error)
	// CurrentPrice queries the current price/s of a specific bond.
	CurrentPrice(context.Context, *QueryCurrentPriceRequest) (*QueryCurrentPriceResponse, error)
	// CurrentReserve queries the current balance/s of the reserve pool for a
	// specific bond.
	CurrentReserve(context.Context, *QueryCurrentReserveRequest) (*QueryCurrentReserveResponse, error)
	// AvailableReserve queries current available balance/s of the reserve pool
	// for a specific bond.
	AvailableReserve(context.Context, *QueryAvailableReserveRequest) (*QueryAvailableReserveResponse, error)
	// CustomPrice queries price/s of a specific bond at a specific supply.
	CustomPrice(context.Context, *QueryCustomPriceRequest) (*QueryCustomPriceResponse, error)
	// BuyPrice queries price/s of buying an amount of tokens from a specific
	// bond.
	BuyPrice(context.Context, *QueryBuyPriceRequest) (*QueryBuyPriceResponse, error)
	// SellReturn queries return/s on selling an amount of tokens of a specific
	// bond.
	SellReturn(context.Context, *QuerySellReturnRequest) (*QuerySellReturnResponse, error)
	// SwapReturn queries return/s on swapping an amount of tokens to another
	// token of a specific bond.
	SwapReturn(context.Context, *QuerySwapReturnRequest) (*QuerySwapReturnResponse, error)
	// AlphaMaximums queries alpha maximums for a specific augmented bonding
	// curve.
	AlphaMaximums(context.Context, *QueryAlphaMaximumsRequest) (*QueryAlphaMaximumsResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) Bonds(ctx context.Context, req *QueryBondsRequest) (*QueryBondsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Bonds not implemented")
}
func (*UnimplementedQueryServer) BondsDetailed(ctx context.Context, req *QueryBondsDetailedRequest) (*QueryBondsDetailedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BondsDetailed not implemented")
}
func (*UnimplementedQueryServer) Params(ctx context.Context, req *QueryParamsRequest) (*QueryParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Params not implemented")
}
func (*UnimplementedQueryServer) Bond(ctx context.Context, req *QueryBondRequest) (*QueryBondResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Bond not implemented")
}
func (*UnimplementedQueryServer) Batch(ctx context.Context, req *QueryBatchRequest) (*QueryBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Batch not implemented")
}
func (*UnimplementedQueryServer) LastBatch(ctx context.Context, req *QueryLastBatchRequest) (*QueryLastBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LastBatch not implemented")
}
func (*UnimplementedQueryServer) CurrentPrice(ctx context.Context, req *QueryCurrentPriceRequest) (*QueryCurrentPriceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CurrentPrice not implemented")
}
func (*UnimplementedQueryServer) CurrentReserve(ctx context.Context, req *QueryCurrentReserveRequest) (*QueryCurrentReserveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CurrentReserve not implemented")
}
func (*UnimplementedQueryServer) AvailableReserve(ctx context.Context, req *QueryAvailableReserveRequest) (*QueryAvailableReserveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AvailableReserve not implemented")
}
func (*UnimplementedQueryServer) CustomPrice(ctx context.Context, req *QueryCustomPriceRequest) (*QueryCustomPriceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CustomPrice not implemented")
}
func (*UnimplementedQueryServer) BuyPrice(ctx context.Context, req *QueryBuyPriceRequest) (*QueryBuyPriceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuyPrice not implemented")
}
func (*UnimplementedQueryServer) SellReturn(ctx context.Context, req *QuerySellReturnRequest) (*QuerySellReturnResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SellReturn not implemented")
}
func (*UnimplementedQueryServer) SwapReturn(ctx context.Context, req *QuerySwapReturnRequest) (*QuerySwapReturnResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SwapReturn not implemented")
}
func (*UnimplementedQueryServer) AlphaMaximums(ctx context.Context, req *QueryAlphaMaximumsRequest) (*QueryAlphaMaximumsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AlphaMaximums not implemented")
}

func RegisterQueryServer(s grpc1.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_Bonds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryBondsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Bonds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ixo.bonds.v1beta1.Query/Bonds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Bonds(ctx, req.(*QueryBondsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_BondsDetailed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryBondsDetailedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).BondsDetailed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ixo.bonds.v1beta1.Query/BondsDetailed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).BondsDetailed(ctx, req.(*QueryBondsDetailedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Params_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Params(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ixo.bonds.v1beta1.Query/Params",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Params(ctx, req.(*QueryParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Bond_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryBondRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Bond(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ixo.bonds.v1beta1.Query/Bond",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Bond(ctx, req.(*QueryBondRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Batch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Batch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ixo.bonds.v1beta1.Query/Batch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Batch(ctx, req.(*QueryBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_LastBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryLastBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).LastBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ixo.bonds.v1beta1.Query/LastBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).LastBatch(ctx, req.(*QueryLastBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_CurrentPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryCurrentPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).CurrentPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ixo.bonds.v1beta1.Query/CurrentPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).CurrentPrice(ctx, req.(*QueryCurrentPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_CurrentReserve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryCurrentReserveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).CurrentReserve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ixo.bonds.v1beta1.Query/CurrentReserve",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).CurrentReserve(ctx, req.(*QueryCurrentReserveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AvailableReserve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAvailableReserveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AvailableReserve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ixo.bonds.v1beta1.Query/AvailableReserve",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AvailableReserve(ctx, req.(*QueryAvailableReserveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_CustomPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryCustomPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).CustomPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ixo.bonds.v1beta1.Query/CustomPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).CustomPrice(ctx, req.(*QueryCustomPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_BuyPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryBuyPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).BuyPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ixo.bonds.v1beta1.Query/BuyPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).BuyPrice(ctx, req.(*QueryBuyPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_SellReturn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySellReturnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).SellReturn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ixo.bonds.v1beta1.Query/SellReturn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).SellReturn(ctx, req.(*QuerySellReturnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_SwapReturn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySwapReturnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).SwapReturn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ixo.bonds.v1beta1.Query/SwapReturn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).SwapReturn(ctx, req.(*QuerySwapReturnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AlphaMaximums_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAlphaMaximumsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AlphaMaximums(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ixo.bonds.v1beta1.Query/AlphaMaximums",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AlphaMaximums(ctx, req.(*QueryAlphaMaximumsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ixo.bonds.v1beta1.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Bonds",
			Handler:    _Query_Bonds_Handler,
		},
		{
			MethodName: "BondsDetailed",
			Handler:    _Query_BondsDetailed_Handler,
		},
		{
			MethodName: "Params",
			Handler:    _Query_Params_Handler,
		},
		{
			MethodName: "Bond",
			Handler:    _Query_Bond_Handler,
		},
		{
			MethodName: "Batch",
			Handler:    _Query_Batch_Handler,
		},
		{
			MethodName: "LastBatch",
			Handler:    _Query_LastBatch_Handler,
		},
		{
			MethodName: "CurrentPrice",
			Handler:    _Query_CurrentPrice_Handler,
		},
		{
			MethodName: "CurrentReserve",
			Handler:    _Query_CurrentReserve_Handler,
		},
		{
			MethodName: "AvailableReserve",
			Handler:    _Query_AvailableReserve_Handler,
		},
		{
			MethodName: "CustomPrice",
			Handler:    _Query_CustomPrice_Handler,
		},
		{
			MethodName: "BuyPrice",
			Handler:    _Query_BuyPrice_Handler,
		},
		{
			MethodName: "SellReturn",
			Handler:    _Query_SellReturn_Handler,
		},
		{
			MethodName: "SwapReturn",
			Handler:    _Query_SwapReturn_Handler,
		},
		{
			MethodName: "AlphaMaximums",
			Handler:    _Query_AlphaMaximums_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ixo/bonds/v1beta1/query.proto",
}

func (m *QueryBondsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBondsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBondsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryBondsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBondsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBondsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Bonds) > 0 {
		for iNdEx := len(m.Bonds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Bonds[iNdEx])
			copy(dAtA[i:], m.Bonds[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.Bonds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryBondsDetailedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBondsDetailedRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBondsDetailedRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryBondsDetailedResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBondsDetailedResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBondsDetailedResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BondsDetailed) > 0 {
		for iNdEx := len(m.BondsDetailed) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BondsDetailed[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryBondRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBondRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBondRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BondDid) > 0 {
		i -= len(m.BondDid)
		copy(dAtA[i:], m.BondDid)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.BondDid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryBondResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBondResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBondResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Bond != nil {
		{
			size, err := m.Bond.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryBatchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBatchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBatchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BondDid) > 0 {
		i -= len(m.BondDid)
		copy(dAtA[i:], m.BondDid)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.BondDid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryBatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBatchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBatchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Batch != nil {
		{
			size, err := m.Batch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryLastBatchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryLastBatchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryLastBatchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BondDid) > 0 {
		i -= len(m.BondDid)
		copy(dAtA[i:], m.BondDid)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.BondDid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryLastBatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryLastBatchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryLastBatchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastBatch != nil {
		{
			size, err := m.LastBatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryCurrentPriceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryCurrentPriceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryCurrentPriceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BondDid) > 0 {
		i -= len(m.BondDid)
		copy(dAtA[i:], m.BondDid)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.BondDid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryCurrentPriceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryCurrentPriceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryCurrentPriceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CurrentPrice) > 0 {
		for iNdEx := len(m.CurrentPrice) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CurrentPrice[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryCurrentReserveRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryCurrentReserveRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryCurrentReserveRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BondDid) > 0 {
		i -= len(m.BondDid)
		copy(dAtA[i:], m.BondDid)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.BondDid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryCurrentReserveResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryCurrentReserveResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryCurrentReserveResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CurrentReserve) > 0 {
		for iNdEx := len(m.CurrentReserve) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CurrentReserve[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryAvailableReserveRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAvailableReserveRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAvailableReserveRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BondDid) > 0 {
		i -= len(m.BondDid)
		copy(dAtA[i:], m.BondDid)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.BondDid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAvailableReserveResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAvailableReserveResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAvailableReserveResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AvailableReserve) > 0 {
		for iNdEx := len(m.AvailableReserve) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AvailableReserve[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryCustomPriceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryCustomPriceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryCustomPriceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BondAmount) > 0 {
		i -= len(m.BondAmount)
		copy(dAtA[i:], m.BondAmount)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.BondAmount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BondDid) > 0 {
		i -= len(m.BondDid)
		copy(dAtA[i:], m.BondDid)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.BondDid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryCustomPriceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryCustomPriceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryCustomPriceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Price) > 0 {
		for iNdEx := len(m.Price) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Price[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryBuyPriceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBuyPriceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBuyPriceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BondAmount) > 0 {
		i -= len(m.BondAmount)
		copy(dAtA[i:], m.BondAmount)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.BondAmount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BondDid) > 0 {
		i -= len(m.BondDid)
		copy(dAtA[i:], m.BondDid)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.BondDid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryBuyPriceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBuyPriceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBuyPriceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TotalFees) > 0 {
		for iNdEx := len(m.TotalFees) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalFees[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.TotalPrices) > 0 {
		for iNdEx := len(m.TotalPrices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalPrices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TxFees) > 0 {
		for iNdEx := len(m.TxFees) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TxFees[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Prices) > 0 {
		for iNdEx := len(m.Prices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Prices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.AdjustedSupply.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QuerySellReturnRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySellReturnRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySellReturnRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BondAmount) > 0 {
		i -= len(m.BondAmount)
		copy(dAtA[i:], m.BondAmount)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.BondAmount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BondDid) > 0 {
		i -= len(m.BondDid)
		copy(dAtA[i:], m.BondDid)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.BondDid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QuerySellReturnResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySellReturnResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySellReturnResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TotalFees) > 0 {
		for iNdEx := len(m.TotalFees) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalFees[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.TotalReturns) > 0 {
		for iNdEx := len(m.TotalReturns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalReturns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ExitFees) > 0 {
		for iNdEx := len(m.ExitFees) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExitFees[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TxFees) > 0 {
		for iNdEx := len(m.TxFees) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TxFees[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Returns) > 0 {
		for iNdEx := len(m.Returns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Returns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.AdjustedSupply.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QuerySwapReturnRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySwapReturnRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySwapReturnRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ToToken) > 0 {
		i -= len(m.ToToken)
		copy(dAtA[i:], m.ToToken)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ToToken)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FromTokenWithAmount) > 0 {
		i -= len(m.FromTokenWithAmount)
		copy(dAtA[i:], m.FromTokenWithAmount)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FromTokenWithAmount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BondDid) > 0 {
		i -= len(m.BondDid)
		copy(dAtA[i:], m.BondDid)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.BondDid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QuerySwapReturnResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySwapReturnResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySwapReturnResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TotalFees) > 0 {
		for iNdEx := len(m.TotalFees) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalFees[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.TotalReturns) > 0 {
		for iNdEx := len(m.TotalReturns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalReturns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryAlphaMaximumsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAlphaMaximumsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAlphaMaximumsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BondDid) > 0 {
		i -= len(m.BondDid)
		copy(dAtA[i:], m.BondDid)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.BondDid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAlphaMaximumsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAlphaMaximumsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAlphaMaximumsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MaxSystemAlpha.Size()
		i -= size
		if _, err := m.MaxSystemAlpha.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.MaxSystemAlphaIncrease.Size()
		i -= size
		if _, err := m.MaxSystemAlphaIncrease.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryParamsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParamsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QueryBondsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryBondsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Bonds) > 0 {
		for _, s := range m.Bonds {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryBondsDetailedRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryBondsDetailedResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BondsDetailed) > 0 {
		for _, e := range m.BondsDetailed {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryBondRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BondDid)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryBondResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bond != nil {
		l = m.Bond.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryBatchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BondDid)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryBatchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Batch != nil {
		l = m.Batch.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryLastBatchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BondDid)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryLastBatchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastBatch != nil {
		l = m.LastBatch.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryCurrentPriceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BondDid)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryCurrentPriceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CurrentPrice) > 0 {
		for _, e := range m.CurrentPrice {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryCurrentReserveRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BondDid)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryCurrentReserveResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CurrentReserve) > 0 {
		for _, e := range m.CurrentReserve {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryAvailableReserveRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BondDid)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAvailableReserveResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AvailableReserve) > 0 {
		for _, e := range m.AvailableReserve {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryCustomPriceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BondDid)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.BondAmount)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryCustomPriceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Price) > 0 {
		for _, e := range m.Price {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryBuyPriceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BondDid)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.BondAmount)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryBuyPriceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AdjustedSupply.Size()
	n += 1 + l + sovQuery(uint64(l))
	if len(m.Prices) > 0 {
		for _, e := range m.Prices {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.TxFees) > 0 {
		for _, e := range m.TxFees {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.TotalPrices) > 0 {
		for _, e := range m.TotalPrices {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.TotalFees) > 0 {
		for _, e := range m.TotalFees {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QuerySellReturnRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BondDid)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.BondAmount)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QuerySellReturnResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AdjustedSupply.Size()
	n += 1 + l + sovQuery(uint64(l))
	if len(m.Returns) > 0 {
		for _, e := range m.Returns {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.TxFees) > 0 {
		for _, e := range m.TxFees {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.ExitFees) > 0 {
		for _, e := range m.ExitFees {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.TotalReturns) > 0 {
		for _, e := range m.TotalReturns {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.TotalFees) > 0 {
		for _, e := range m.TotalFees {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QuerySwapReturnRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BondDid)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.FromTokenWithAmount)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.ToToken)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QuerySwapReturnResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TotalReturns) > 0 {
		for _, e := range m.TotalReturns {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.TotalFees) > 0 {
		for _, e := range m.TotalFees {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryAlphaMaximumsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BondDid)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAlphaMaximumsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MaxSystemAlphaIncrease.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.MaxSystemAlpha.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryParamsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QueryBondsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBondsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBondsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBondsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBondsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBondsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bonds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bonds = append(m.Bonds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBondsDetailedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBondsDetailedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBondsDetailedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBondsDetailedResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBondsDetailedResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBondsDetailedResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondsDetailed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondsDetailed = append(m.BondsDetailed, &BondDetails{})
			if err := m.BondsDetailed[len(m.BondsDetailed)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBondRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBondRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBondRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondDid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBondResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBondResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBondResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bond == nil {
				m.Bond = &Bond{}
			}
			if err := m.Bond.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBatchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBatchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBatchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondDid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Batch == nil {
				m.Batch = &Batch{}
			}
			if err := m.Batch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryLastBatchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryLastBatchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryLastBatchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondDid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryLastBatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryLastBatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryLastBatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastBatch == nil {
				m.LastBatch = &Batch{}
			}
			if err := m.LastBatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryCurrentPriceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryCurrentPriceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryCurrentPriceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondDid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryCurrentPriceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryCurrentPriceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryCurrentPriceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentPrice = append(m.CurrentPrice, types.DecCoin{})
			if err := m.CurrentPrice[len(m.CurrentPrice)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryCurrentReserveRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryCurrentReserveRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryCurrentReserveRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondDid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryCurrentReserveResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryCurrentReserveResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryCurrentReserveResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentReserve", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentReserve = append(m.CurrentReserve, types.Coin{})
			if err := m.CurrentReserve[len(m.CurrentReserve)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAvailableReserveRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAvailableReserveRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAvailableReserveRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondDid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAvailableReserveResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAvailableReserveResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAvailableReserveResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableReserve", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailableReserve = append(m.AvailableReserve, types.Coin{})
			if err := m.AvailableReserve[len(m.AvailableReserve)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryCustomPriceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryCustomPriceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryCustomPriceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondDid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryCustomPriceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryCustomPriceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryCustomPriceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Price = append(m.Price, types.DecCoin{})
			if err := m.Price[len(m.Price)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBuyPriceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBuyPriceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBuyPriceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondDid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBuyPriceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBuyPriceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBuyPriceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdjustedSupply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AdjustedSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prices = append(m.Prices, types.Coin{})
			if err := m.Prices[len(m.Prices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxFees", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxFees = append(m.TxFees, types.Coin{})
			if err := m.TxFees[len(m.TxFees)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPrices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalPrices = append(m.TotalPrices, types.Coin{})
			if err := m.TotalPrices[len(m.TotalPrices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFees", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalFees = append(m.TotalFees, types.Coin{})
			if err := m.TotalFees[len(m.TotalFees)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySellReturnRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySellReturnRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySellReturnRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondDid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySellReturnResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySellReturnResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySellReturnResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdjustedSupply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AdjustedSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Returns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Returns = append(m.Returns, types.Coin{})
			if err := m.Returns[len(m.Returns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxFees", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxFees = append(m.TxFees, types.Coin{})
			if err := m.TxFees[len(m.TxFees)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitFees", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExitFees = append(m.ExitFees, types.Coin{})
			if err := m.ExitFees[len(m.ExitFees)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalReturns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalReturns = append(m.TotalReturns, types.Coin{})
			if err := m.TotalReturns[len(m.TotalReturns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFees", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalFees = append(m.TotalFees, types.Coin{})
			if err := m.TotalFees[len(m.TotalFees)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySwapReturnRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySwapReturnRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySwapReturnRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondDid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromTokenWithAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromTokenWithAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySwapReturnResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySwapReturnResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySwapReturnResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalReturns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalReturns = append(m.TotalReturns, types.Coin{})
			if err := m.TotalReturns[len(m.TotalReturns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFees", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalFees = append(m.TotalFees, types.Coin{})
			if err := m.TotalFees[len(m.TotalFees)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAlphaMaximumsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAlphaMaximumsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAlphaMaximumsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondDid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAlphaMaximumsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAlphaMaximumsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAlphaMaximumsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSystemAlphaIncrease", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxSystemAlphaIncrease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSystemAlpha", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxSystemAlpha.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryParamsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParamsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
